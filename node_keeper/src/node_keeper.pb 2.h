// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: node_keeper.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_node_5fkeeper_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_node_5fkeeper_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/any.pb.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/field_mask.pb.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>

#include <google/protobuf/port_undef.inc>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_node_5fkeeper_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_node_5fkeeper_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField
      entries[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField
      aux[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable
      schema[5] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata
      field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable
      serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_node_5fkeeper_2eproto;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class GetMembersReply;
class GetMembersReplyDefaultTypeInternal;
extern GetMembersReplyDefaultTypeInternal _GetMembersReply_default_instance_;
class Member;
class MemberDefaultTypeInternal;
extern MemberDefaultTypeInternal _Member_default_instance_;
class MemberEvent;
class MemberEventDefaultTypeInternal;
extern MemberEventDefaultTypeInternal _MemberEvent_default_instance_;
class SubscribeRequest;
class SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template <>
::Event* Arena::CreateMaybeMessage<::Event>(Arena*);
template <>
::GetMembersReply* Arena::CreateMaybeMessage<::GetMembersReply>(Arena*);
template <>
::Member* Arena::CreateMaybeMessage<::Member>(Arena*);
template <>
::MemberEvent* Arena::CreateMaybeMessage<::MemberEvent>(Arena*);
template <>
::SubscribeRequest* Arena::CreateMaybeMessage<::SubscribeRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Event_Type : int {
  Event_Type_UNKNOWN = 0,
  Event_Type_MEMBER_CHANGED = 1,
  Event_Type_Event_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Event_Type_Event_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Event_Type_IsValid(int value);
constexpr Event_Type Event_Type_Type_MIN = Event_Type_UNKNOWN;
constexpr Event_Type Event_Type_Type_MAX = Event_Type_MEMBER_CHANGED;
constexpr int Event_Type_Type_ARRAYSIZE = Event_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Event_Type_descriptor();
template <typename T>
inline const std::string& Event_Type_Name(T enum_t_value) {
  static_assert(
      ::std::is_same<T, Event_Type>::value || ::std::is_integral<T>::value,
      "Incorrect type passed to function Event_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(Event_Type_descriptor(),
                                                       enum_t_value);
}
inline bool Event_Type_Parse(const std::string& name, Event_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Event_Type>(
      Event_Type_descriptor(), name, value);
}
enum MemberEvent_Status : int {
  MemberEvent_Status_UNKNOWN = 0,
  MemberEvent_Status_UP = 1,
  MemberEvent_Status_DOWN = 2,
  MemberEvent_Status_MemberEvent_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MemberEvent_Status_MemberEvent_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MemberEvent_Status_IsValid(int value);
constexpr MemberEvent_Status MemberEvent_Status_Status_MIN =
    MemberEvent_Status_UNKNOWN;
constexpr MemberEvent_Status MemberEvent_Status_Status_MAX =
    MemberEvent_Status_DOWN;
constexpr int MemberEvent_Status_Status_ARRAYSIZE =
    MemberEvent_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MemberEvent_Status_descriptor();
template <typename T>
inline const std::string& MemberEvent_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MemberEvent_Status>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to function MemberEvent_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
      MemberEvent_Status_descriptor(), enum_t_value);
}
inline bool MemberEvent_Status_Parse(const std::string& name,
                                     MemberEvent_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MemberEvent_Status>(
      MemberEvent_Status_descriptor(), name, value);
}
// ===================================================================

class Member
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:Member) */ {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);
  Member(Member&& from) noexcept : Member() { *this = ::std::move(from); }

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline Member& operator=(Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Member* internal_default_instance() {
    return reinterpret_cast<const Member*>(&_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;

  friend void swap(Member& a, Member& b) { a.Swap(&b); }
  inline void Swap(Member* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Member* New() const final {
    return CreateMaybeMessage<Member>(nullptr);
  }

  Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Member>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Member* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Member";
  }

 private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const { return nullptr; }

 public:
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

 private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
        &::descriptor_table_node_5fkeeper_2eproto);
    return ::descriptor_table_node_5fkeeper_2eproto
        .file_level_metadata[kIndexInFileMessages];
  }

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);

  // uint32 port = 3;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:Member)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena
      _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_5fkeeper_2eproto;
};
// -------------------------------------------------------------------

class GetMembersReply : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetMembersReply)
                                                                 */
{
 public:
  GetMembersReply();
  virtual ~GetMembersReply();

  GetMembersReply(const GetMembersReply& from);
  GetMembersReply(GetMembersReply&& from) noexcept : GetMembersReply() {
    *this = ::std::move(from);
  }

  inline GetMembersReply& operator=(const GetMembersReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMembersReply& operator=(GetMembersReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetMembersReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMembersReply* internal_default_instance() {
    return reinterpret_cast<const GetMembersReply*>(
        &_GetMembersReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;

  friend void swap(GetMembersReply& a, GetMembersReply& b) { a.Swap(&b); }
  inline void Swap(GetMembersReply* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetMembersReply* New() const final {
    return CreateMaybeMessage<GetMembersReply>(nullptr);
  }

  GetMembersReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetMembersReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetMembersReply& from);
  void MergeFrom(const GetMembersReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMembersReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetMembersReply";
  }

 private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const { return nullptr; }

 public:
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

 private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
        &::descriptor_table_node_5fkeeper_2eproto);
    return ::descriptor_table_node_5fkeeper_2eproto
        .file_level_metadata[kIndexInFileMessages];
  }

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 1,
  };
  // repeated .Member members = 1;
  int members_size() const;
  void clear_members();
  ::Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Member>* mutable_members();
  const ::Member& members(int index) const;
  ::Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Member>& members() const;

  // @@protoc_insertion_point(class_scope:GetMembersReply)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena
      _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Member> members_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_5fkeeper_2eproto;
};
// -------------------------------------------------------------------

class SubscribeRequest : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SubscribeRequest)
                                                                  */
{
 public:
  SubscribeRequest();
  virtual ~SubscribeRequest();

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubscribeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
        &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeRequest* New() const final {
    return CreateMaybeMessage<SubscribeRequest>(nullptr);
  }

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubscribeRequest& from);
  void MergeFrom(const SubscribeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubscribeRequest";
  }

 private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const { return nullptr; }

 public:
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

 private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
        &::descriptor_table_node_5fkeeper_2eproto);
    return ::descriptor_table_node_5fkeeper_2eproto
        .file_level_metadata[kIndexInFileMessages];
  }

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaskFieldNumber = 1,
  };
  // .google.protobuf.FieldMask mask = 1;
  bool has_mask() const;
  void clear_mask();
  const PROTOBUF_NAMESPACE_ID::FieldMask& mask() const;
  PROTOBUF_NAMESPACE_ID::FieldMask* release_mask();
  PROTOBUF_NAMESPACE_ID::FieldMask* mutable_mask();
  void set_allocated_mask(PROTOBUF_NAMESPACE_ID::FieldMask* mask);

  // @@protoc_insertion_point(class_scope:SubscribeRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena
      _internal_metadata_;
  PROTOBUF_NAMESPACE_ID::FieldMask* mask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_5fkeeper_2eproto;
};
// -------------------------------------------------------------------

class Event
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);
  Event(Event&& from) noexcept : Event() { *this = ::std::move(from); }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(&_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;

  friend void swap(Event& a, Event& b) { a.Swap(&b); }
  inline void Swap(Event* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final { return CreateMaybeMessage<Event>(nullptr); }

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Event";
  }

 private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const { return nullptr; }

 public:
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

 private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
        &::descriptor_table_node_5fkeeper_2eproto);
    return ::descriptor_table_node_5fkeeper_2eproto
        .file_level_metadata[kIndexInFileMessages];
  }

 public:
  // nested types ----------------------------------------------------

  typedef Event_Type Type;
  static constexpr Type UNKNOWN = Event_Type_UNKNOWN;
  static constexpr Type MEMBER_CHANGED = Event_Type_MEMBER_CHANGED;
  static inline bool Type_IsValid(int value) {
    return Event_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Event_Type_Type_MIN;
  static constexpr Type Type_MAX = Event_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Event_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Event_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(
        ::std::is_same<T, Type>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function Type_Name.");
    return Event_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name, Type* value) {
    return Event_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .google.protobuf.Any data = 2;
  bool has_data() const;
  void clear_data();
  const PROTOBUF_NAMESPACE_ID::Any& data() const;
  PROTOBUF_NAMESPACE_ID::Any* release_data();
  PROTOBUF_NAMESPACE_ID::Any* mutable_data();
  void set_allocated_data(PROTOBUF_NAMESPACE_ID::Any* data);

  // .Event.Type type = 1;
  void clear_type();
  ::Event_Type type() const;
  void set_type(::Event_Type value);

  // @@protoc_insertion_point(class_scope:Event)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena
      _internal_metadata_;
  PROTOBUF_NAMESPACE_ID::Any* data_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_5fkeeper_2eproto;
};
// -------------------------------------------------------------------

class MemberEvent
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:MemberEvent) */ {
 public:
  MemberEvent();
  virtual ~MemberEvent();

  MemberEvent(const MemberEvent& from);
  MemberEvent(MemberEvent&& from) noexcept : MemberEvent() {
    *this = ::std::move(from);
  }

  inline MemberEvent& operator=(const MemberEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberEvent& operator=(MemberEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MemberEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemberEvent* internal_default_instance() {
    return reinterpret_cast<const MemberEvent*>(
        &_MemberEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;

  friend void swap(MemberEvent& a, MemberEvent& b) { a.Swap(&b); }
  inline void Swap(MemberEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MemberEvent* New() const final {
    return CreateMaybeMessage<MemberEvent>(nullptr);
  }

  MemberEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemberEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MemberEvent& from);
  void MergeFrom(const MemberEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

 private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MemberEvent";
  }

 private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const { return nullptr; }

 public:
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

 private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
        &::descriptor_table_node_5fkeeper_2eproto);
    return ::descriptor_table_node_5fkeeper_2eproto
        .file_level_metadata[kIndexInFileMessages];
  }

 public:
  // nested types ----------------------------------------------------

  typedef MemberEvent_Status Status;
  static constexpr Status UNKNOWN = MemberEvent_Status_UNKNOWN;
  static constexpr Status UP = MemberEvent_Status_UP;
  static constexpr Status DOWN = MemberEvent_Status_DOWN;
  static inline bool Status_IsValid(int value) {
    return MemberEvent_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = MemberEvent_Status_Status_MIN;
  static constexpr Status Status_MAX = MemberEvent_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = MemberEvent_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return MemberEvent_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(
        ::std::is_same<T, Status>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function Status_Name.");
    return MemberEvent_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(const std::string& name, Status* value) {
    return MemberEvent_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .Member member = 1;
  bool has_member() const;
  void clear_member();
  const ::Member& member() const;
  ::Member* release_member();
  ::Member* mutable_member();
  void set_allocated_member(::Member* member);

  // .MemberEvent.Status status = 2;
  void clear_status();
  ::MemberEvent_Status status() const;
  void set_status(::MemberEvent_Status value);

  // @@protoc_insertion_point(class_scope:MemberEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena
      _internal_metadata_;
  ::Member* member_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_5fkeeper_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Member

// string name = 1;
inline void Member::clear_name() {
  name_.ClearToEmptyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Member::name() const {
  // @@protoc_insertion_point(field_get:Member.name)
  return name_.GetNoArena();
}
inline void Member::set_name(const std::string& value) {
  name_.SetNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Member.name)
}
inline void Member::set_name(std::string&& value) {
  name_.SetNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Member.name)
}
inline void Member::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  name_.SetNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Member.name)
}
inline void Member::set_name(const char* value, size_t size) {
  name_.SetNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Member.name)
}
inline std::string* Member::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Member.name)
  return name_.MutableNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Member::release_name() {
  // @@protoc_insertion_point(field_release:Member.name)

  return name_.ReleaseNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Member::set_allocated_name(std::string* name) {
  if (name != nullptr) {
  } else {
  }
  name_.SetAllocatedNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Member.name)
}

// string host = 2;
inline void Member::clear_host() {
  host_.ClearToEmptyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Member::host() const {
  // @@protoc_insertion_point(field_get:Member.host)
  return host_.GetNoArena();
}
inline void Member::set_host(const std::string& value) {
  host_.SetNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Member.host)
}
inline void Member::set_host(std::string&& value) {
  host_.SetNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Member.host)
}
inline void Member::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  host_.SetNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Member.host)
}
inline void Member::set_host(const char* value, size_t size) {
  host_.SetNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Member.host)
}
inline std::string* Member::mutable_host() {
  // @@protoc_insertion_point(field_mutable:Member.host)
  return host_.MutableNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Member::release_host() {
  // @@protoc_insertion_point(field_release:Member.host)

  return host_.ReleaseNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Member::set_allocated_host(std::string* host) {
  if (host != nullptr) {
  } else {
  }
  host_.SetAllocatedNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:Member.host)
}

// uint32 port = 3;
inline void Member::clear_port() { port_ = 0u; }
inline ::PROTOBUF_NAMESPACE_ID::uint32 Member::port() const {
  // @@protoc_insertion_point(field_get:Member.port)
  return port_;
}
inline void Member::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  port_ = value;
  // @@protoc_insertion_point(field_set:Member.port)
}

// -------------------------------------------------------------------

// GetMembersReply

// repeated .Member members = 1;
inline int GetMembersReply::members_size() const { return members_.size(); }
inline void GetMembersReply::clear_members() { members_.Clear(); }
inline ::Member* GetMembersReply::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:GetMembersReply.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Member>*
GetMembersReply::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:GetMembersReply.members)
  return &members_;
}
inline const ::Member& GetMembersReply::members(int index) const {
  // @@protoc_insertion_point(field_get:GetMembersReply.members)
  return members_.Get(index);
}
inline ::Member* GetMembersReply::add_members() {
  // @@protoc_insertion_point(field_add:GetMembersReply.members)
  return members_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Member>&
GetMembersReply::members() const {
  // @@protoc_insertion_point(field_list:GetMembersReply.members)
  return members_;
}

// -------------------------------------------------------------------

// SubscribeRequest

// .google.protobuf.FieldMask mask = 1;
inline bool SubscribeRequest::has_mask() const {
  return this != internal_default_instance() && mask_ != nullptr;
}
inline const PROTOBUF_NAMESPACE_ID::FieldMask& SubscribeRequest::mask() const {
  const PROTOBUF_NAMESPACE_ID::FieldMask* p = mask_;
  // @@protoc_insertion_point(field_get:SubscribeRequest.mask)
  return p != nullptr
             ? *p
             : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::FieldMask*>(
                   &PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* SubscribeRequest::release_mask() {
  // @@protoc_insertion_point(field_release:SubscribeRequest.mask)

  PROTOBUF_NAMESPACE_ID::FieldMask* temp = mask_;
  mask_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* SubscribeRequest::mutable_mask() {
  if (mask_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::FieldMask>(
        GetArenaNoVirtual());
    mask_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SubscribeRequest.mask)
  return mask_;
}
inline void SubscribeRequest::set_allocated_mask(
    PROTOBUF_NAMESPACE_ID::FieldMask* mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mask_);
  }
  if (mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mask)
            ->GetArena();
    if (message_arena != submessage_arena) {
      mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mask, submessage_arena);
    }

  } else {
  }
  mask_ = mask;
  // @@protoc_insertion_point(field_set_allocated:SubscribeRequest.mask)
}

// -------------------------------------------------------------------

// Event

// .Event.Type type = 1;
inline void Event::clear_type() { type_ = 0; }
inline ::Event_Type Event::type() const {
  // @@protoc_insertion_point(field_get:Event.type)
  return static_cast<::Event_Type>(type_);
}
inline void Event::set_type(::Event_Type value) {
  type_ = value;
  // @@protoc_insertion_point(field_set:Event.type)
}

// .google.protobuf.Any data = 2;
inline bool Event::has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline const PROTOBUF_NAMESPACE_ID::Any& Event::data() const {
  const PROTOBUF_NAMESPACE_ID::Any* p = data_;
  // @@protoc_insertion_point(field_get:Event.data)
  return p != nullptr ? *p
                      : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Any*>(
                            &PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::Any* Event::release_data() {
  // @@protoc_insertion_point(field_release:Event.data)

  PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* Event::mutable_data() {
  if (data_ == nullptr) {
    auto* p =
        CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Any>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Event.data)
  return data_;
}
inline void Event::set_allocated_data(PROTOBUF_NAMESPACE_ID::Any* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }

  } else {
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:Event.data)
}

// -------------------------------------------------------------------

// MemberEvent

// .Member member = 1;
inline bool MemberEvent::has_member() const {
  return this != internal_default_instance() && member_ != nullptr;
}
inline void MemberEvent::clear_member() {
  if (GetArenaNoVirtual() == nullptr && member_ != nullptr) {
    delete member_;
  }
  member_ = nullptr;
}
inline const ::Member& MemberEvent::member() const {
  const ::Member* p = member_;
  // @@protoc_insertion_point(field_get:MemberEvent.member)
  return p != nullptr
             ? *p
             : *reinterpret_cast<const ::Member*>(&::_Member_default_instance_);
}
inline ::Member* MemberEvent::release_member() {
  // @@protoc_insertion_point(field_release:MemberEvent.member)

  ::Member* temp = member_;
  member_ = nullptr;
  return temp;
}
inline ::Member* MemberEvent::mutable_member() {
  if (member_ == nullptr) {
    auto* p = CreateMaybeMessage<::Member>(GetArenaNoVirtual());
    member_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MemberEvent.member)
  return member_;
}
inline void MemberEvent::set_allocated_member(::Member* member) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete member_;
  }
  if (member) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      member = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, member, submessage_arena);
    }

  } else {
  }
  member_ = member;
  // @@protoc_insertion_point(field_set_allocated:MemberEvent.member)
}

// .MemberEvent.Status status = 2;
inline void MemberEvent::clear_status() { status_ = 0; }
inline ::MemberEvent_Status MemberEvent::status() const {
  // @@protoc_insertion_point(field_get:MemberEvent.status)
  return static_cast<::MemberEvent_Status>(status_);
}
inline void MemberEvent::set_status(::MemberEvent_Status value) {
  status_ = value;
  // @@protoc_insertion_point(field_set:MemberEvent.status)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::Event_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Event_Type>() {
  return ::Event_Type_descriptor();
}
template <>
struct is_proto_enum<::MemberEvent_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MemberEvent_Status>() {
  return ::MemberEvent_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_node_5fkeeper_2eproto
